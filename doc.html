<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<!--
  Documentation for Jaypha Base.
  Copyright 2015 Jaypha.
  Distributed under the Boost Licence.
  Written by Jason den Dulk.
-->
<head>
<style type='text/css'>
 *
 {
  padding: 0;
  margin: 0;
 }

  body
  {
   font-size: 12px;
   font-family:arial,sans-serif;
  }
 p, table, dd
 {
   margin-bottom: 0.7em;
 }
 h1,h2,h3 { margin-bottom: 0.7em; }
 h1 { font-size: 22px; color: red; }
 h2 { font-size: 18px; color: red; }
 h3 { font-size: 15px; color: red; }
 
 table
 {
  border-collapse: collapse;
 }
 td, th
 {
  padding: 3px;
  border: 1px solid black;
 }
 .d_decl { background-color: #E4E9EF;
    border-bottom: 2px solid #336600;

    padding: 2px 0 2px 2px;
    text-align: left;
    margin-bottom: 0.7em;
    font-family: monospace;
  }
  .funcName { font-weight: bold; }

  .code { font-family: monospace; }

</style>
<title>Jaypha Base Documentation</title>
</head>
<body style=''>
<div style='width:1000px; margin:auto'>

<h1>Jaypha Base Generic Utilities</h1>

<h2>Introduction</h2>

<p>This project contains various generic functions, structs, classes and definitions that
extend the functionality of Phobos. Thery are used in several Jaypha projects and are
kept separate to avoid repetition. They are also useful on their own.</p>

<h2>Module Index</h2>
<p>The modules are</p>
<table>
 <tr><td>jaypha.types</td><td>Commonly used definitions and aliases</td></tr>
 <tr><td>jaypha.algorithm</td><td>Some algorithm routines and templates</td></tr>
 <tr><td>jaypha.conv</td><td>Some conversion routines</td></tr>
 <tr><td>jaypha.range</td><td>Some rountines for use with ranges</td></tr>
 <tr><td>jaypha.rnd</td><td>Wrapper for std.random.rndGen and some useful routines</td></tr>
 <tr><td>jaypha.string</td><td>String utilities</td></tr>
</table>

<h2>Function Index</h2>

<table>
 <thead>
  <tr><th>Name</th><th>Module</th><th>Description</th></tr>
 </thead>
 <tbody>
  <tr><td><a href='#altIndexOf'>altIndexOf</a></td> <td>jaypha.string</td><td>A quick and dirty alternative to indexOf. Only works with ASCII.</td></tr>
  <tr><td><a href='#binToHex'>binToHex</a></td>    <td>jaypha.conv</td><td>Converts an unsigned interger into a hex string.</td></tr>
  <tr><td><a href='#bitsToList'>bitsToList</a></td> <td>jaypha.conv</td><td>Extract the bits from a number and puts them into an aray.</td></tr>
  <tr><td><a href='#ByChunk'>ByChunk</a></td>    <td>jaypha.range</td><td>Splits a range into chunks of given size. Doesn't work with narrow strings.</td></tr>
  <tr><td><a href='#byChunk'>byChunk</a></td>    <td>jaypha.range</td><td>Convenience function for return ByChunk structs</td></tr>
  <tr><td><a href='#diff'>diff</a></td>       <td>jaypha.algorithm</td><td>Returns everything in one array that is not in another</td></tr>
  <tr><td><a href='#drain'>drain</a></td>      <td>jaypha.range</td><td>Consume the rest of the range.</td></tr>
  <tr><td><a href='#findSplit'>findSplit</a></td>  <td>jaypha.algorithm</td><td>Alternative to std.alogrithm.findSplit usable with non-rewindable ranges</td></tr>
  <tr><td><a href='#grab'>grab</a></td>       <td>jaypha.algorithm</td><td>Grabs as much of the given string, until a character is found that is in a supplied pattern.</td></tr>
  <tr><td><a href='#isDigits'>isDigits</a></td>   <td>jaypha.string</td><td>Are all characters digits?</td></tr>
  <tr><td><a href='#listToBits'>listToBits</a></td> <td>jaypha.conv</td><td>Reduces an array to a single value by or-ing them together.</td></tr>
  <tr><td><a href='#meld'>meld</a></td>       <td>jaypha.algorithm</td><td>Map-like algorithm that merges the index and values of an associative array.</td></tr>
  <tr><td><a href='#munch'>munch</a></td>      <td>jaypha.range</td><td>Consumes the front of the range as long the elements are inside pattern.</td></tr>
  <tr><td><a href='#rnd'>rnd</a></td>        <td>jaypha.rnd</td><td>A wrapper for rndGen to prevent copying, provided by monarch_dodra.</td></tr>
  <tr><td><a href='#rndHex'>rndHex</a></td>     <td>jaypha.rnd</td><td>A randomly generated string of hex characters. Useful for filenames.</td></tr>
  <tr><td><a href='#rndId'>rndId</a></td>      <td>jaypha.rnd</td><td>A random string of lower case ASCII letters</td></tr>
  <tr><td><a href='#rndString'>rndString</a></td>  <td>jaypha.rnd</td><td> A random string of ASCII printable characters. Useful for passwords.</td></tr>
  <tr><td><a href='#rtMap'>rtMap</a></td>      <td>jaypha.algorithm</td><td>Similar to std.algorithm.map except that the mapping function is not a template parameter</td></tr>
  <tr><td><a href='#splitUp'>splitUp</a></td>    <td>jaypha.string</td><td>Splits a string into substrings based on a group of possible delimiters</td></tr>
  <tr><td><a href='#toCamelCase'>toCamelCase</a></td><td>jaypha.string</td><td>Converts a string to camel case.</td></tr>
 </tbody>
</table>

<h2>Modules</h2>

<h3>jaypha.algorithm</h3>

<dt class="d_decl">template meld(alias func)<br/>auto <a name="meld"></a><span class="funcName">meld</span>(A)(A array)</dt>
<dd><p>Merges the indexes and values of an associative array using a supplied function.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'><i>func</i></td><td>A function that takes a key,value pair and merges them</td></tr>
<tr><td class='code'><i>array</i></td><td>An associative array to be melded.</td></tr>
</table>
<p><b>Returns:</b><br/>An array containing the results of the meld.</p>
<p><b>Example</b><br/><pre>
  string[string] x = [ "one":"1", "bee":"3", "john":"66" ];

  char[] z;
  auto y = x.meld!((a,b) => (a~b));
  assert (y == [ "one1", "bee3", "john66" ]);
</pre>
</dd>

<dt class="d_decl">T[] <a name="diff"></a><span class="funcName">diff</span>(T)(T[] primary, T[] secondary)</dt>
<dd><p> Returns everything in primary that is not in secondary.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>T[] <i>primary</i></td><td>The array to be adjusted</td></tr>
<tr><td class='code'>T[] <i>secondary</i></td><td>The filter</td></tr>
</table>
<b>Returns:</b><br>An array containing all elements in primary that are not in secondary.
</dd>

<dt class="d_decl">auto <a name="findSplit"></a><span class="funcName">findSplit</span>(R1,R2)(ref R1 haystack, R2 needle)</dt>
<dd><p>Alternative to std.alogrithm.findSplit usable with non-rewindable ranges. Haystack becomes
adjusted to the remaining range.
</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>R1 <i>haystack</i></td><td>The input range to be split.</td></tr>
<tr><td class='code'>R2 <i>needle</i></td><td>The input range to be searcched for that will split the range.</td></tr>
</table>
<p><b>Returns:</b><br>A tuple containing the part of the input prior to the needle, and the needle itself.
If the needle was not found, the tuple will contain the whole input range and an empty range.
The original range will be adjusted to be the remaining input after the needle.</p>
</dd>

<dt class="d_decl">struct <a name="rtMap"></a><span class="funcName">rtMap</span>(R,T) if (isInputRange!R)</dt>
<dd><p>Similar to std.algorithm.map except that the mapping function is not a template parameter.
Instead a delegate is provided at run time when creating the object.
</p>
<p>An rtMap instance defines an input range of type T.</p>

<b>Template Parameters:</b>
<table class='parms'>
<tr><td class='code'>R</td><td>The type of the input range to be mapped.</td></tr>
<tr><td class='code'>T</td><td>The element type of rtMap.</td></tr>
</table>

<b>Methods:</b>
<table class='parms'>
<tr><td class='code'>this(R range, T delegate(ElementType!R) mapper)</td><td>Construct the object with a range and mapper function.</td></tr>
<tr><td class='code'>@property T front()</td><td></td></tr>
<tr><td class='code'>@property bool empty()</td><td></td></tr>
<tr><td class='code'>void popFront()</td><td></td></tr>
</table>

<b>Example:</b><br>
<pre>
  uint m1(uint i) { return i+3; }
  uint m2(uint i) { return i+6; }

  uint[] src = [ 0, 4, 7 ];

  auto rmap = rtMap!(uint[], uint)(src, &amp;m1);

  auto dest = appender!(uint[]);
  rmap.copy(dest);

  assert(dest.data == [ 3, 7, 10 ]);

  rmap = rtMap!(uint[], uint)(src, &amp;m2);

  dest = appender!(uint[]);
  rmap.copy(dest);

  assert(dest.data == [ 6, 10, 13 ]);
</pre>
</dd>

<h3>jaypha.conv</h3>

<dt class="d_decl">@safe pure nothrow string <a name="binToHex"></a><span class="funcName">binToHex</span>(T)(T i) if(__traits(isUnsigned,T))</dt>
<dd><p>Converts an unsigned interger into a hex string..</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>T <i>i</i></td><td>The unsinged integer to be converted.</td></tr>
</table>
<p><b>Returns:</b><br>The number in hex as a string.</p>
</dd>

<dt class="d_decl">@safe pure nothrow T[] <a name="bitsToList"></a><span class="funcName">bitsToList</span>(T)(T bits) if(__traits(isIntegral,T) &amp;&amp; __traits(isUnsigned,T))</dt>
<dd><p>Extract the bits from an integer and puts them into an array. eg. 01101b => [ 1000b, 100b, 1b ].</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>T <i>bits</i></td><td>The unsinged integer to be converted.</td></tr>
</table>
<p><b>Returns:</b><br>An array containing the extracted bits.</p>
</dd>

<dt class="d_decl">@safe @nogc pure nothrow T <a name="listToBits"></a><span class="funcName">listToBits</span>(T)(T[] list) if(__traits(isIntegral,T) &amp;&amp; __traits(isUnsigned,T))</dt>
<dd><p>The reverse of bitsToList, takes a list of values and reduces them together into a single value using binary OR.
eg. [ 1000b, 100b, 1b ] => 01101b</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>T[] <i>list</i></td><td>The aray to be reduced.</td></tr>
</table>
<p><b>Returns:</b><br>The result of or-ing the array values.</p>
</dd>



<h3>jaypha.range</h3>

<dt class="d_decl">void <a name="munch"></a><span class="funcName">munch</span>(R,E)(ref R range, E pattern)
  if (isInputRange!R &amp;&amp; isInputRange!E &amp;&amp;
      isScalarType!(ElementType!E) &amp;&amp; isScalarType!(ElementType!R))</dt>
<dd><p>Consumes the front of <i>range</i> as long the elements are inside <i>pattern</i>.
That is, as long as one of the elements of <i>pattern</i> matches <i>range.front</i>, than range will be popped.
<i>range</i> can be a basic input range.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>ref R <i>range</i></td><td>The input range to be processed.</td></tr>
<tr><td class='code'>E <i>pattern</i></td><td>An input range of the same element type of the range</td></tr>
</table>
</dd>

<dt class="d_decl">void <a name="drain"></a><span class="funcName">drain</span>(R)(ref R r) if (isInputRange!R)</dt>
<dd><p>Pops <i>range</i> until <i>range.empty</i> is true.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>ref R <i>range</i></td><td>The input range to be drained.</td></tr>
</table>
</dd>

<dt class="d_decl">struct <a name="ByChunk"><span class="funcName">ByChunk</span>(R) if (!isNarrowString!R)</a></dt>
<dd><p>Allows a range to be traversed in chunks. Shouldn't be used with narrow strings as
a character may be chopped in half.</p>

<b>Methods:</b>
<table class='parms'>
<tr><td class='code'>this(R range, size_t chunkSize)</td><td></td></tr>
<tr><td class='code'>@property T front()</td><td>Gives a subrange of chuckSize length (or less if at end of range)</td></tr>
<tr><td class='code'>@property bool empty()</td><td></td></tr>
<tr><td class='code'>void popFront()</td><td>Pops chunkSize elements off the range.</td></tr>
</table>
</dd>

<dt class="d_decl">ByChunk!R <a name="byChunk"></a><span class="funcName">byChunk</span>(R)(R range, size_t chunckSize)</dt>
<dd><p>A convenience function for making ByChunk instances.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>R <i>range</i></td><td>The input range.</td></tr>
<tr><td class='code'>size_t <i>chunkSize</i></td><td>The size of the chunks</td></tr>
</table>
<p><b>Returns:</b><br>A <i>ByChunk</i> instance initialised with the range and chunk size.</p>
</dd>

<h3>jaypha.rnd</h3>

<dt class="d_decl">struct Rnd<br/>
Rnd <a name="rnd"></a><span class="funcName">rnd</span>()</dt>
<dd><p>A wrapper for std.random.rndGen to prevent repitition caused by copying. This structure
was provided by monarch_dodra. You use it the same way you use rndGen.</p>
</dd>

<dt class="d_decl">string <a name="rndHex"></a><span class="funcName">rndHex</span>(size_t size)</dt>
<dd><p>Creates a randomly generated string of hex characters.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>size_t <i>size</i></td><td>The number of charcters to generate.</td></tr>
</table>
</dd>

<dt class="d_decl">string <a name="rndString"></a><span class="funcName">rndString</span>(size_t size)</dt>
<dd><p>Creates a randomly generated string of ASCII printable characters.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>size_t <i>size</i></td><td>The number of charcters to generate.</td></tr>
</table>
</dd>

<dt class="d_decl">string <a name="rndId"></a><span class="funcName">rndId</span>(size_t size)</dt>
<dd><p>Creates a randomly generated string of lower case ASCII letters.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>size_t <i>size</i></td><td>The number of charcters to generate.</td></tr>
</table>
</dd>

<h3>jaypha.string</h3>

<dl><dt class="d_decl">string[] <a name="splitUp"></a><span class="funcName">splitUp</span>(string text, const(char)[] delimiters)</dt>
<dd><p>Splits a string into substrings based on a group of possible delimiters. The delimiters do not all have to be the same</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>string <i>text</i></td><td>The string to be split</td></tr>
<tr><td class='code'>const(char)[] <i>delimeters</i></td><td>An array containing all possible delimiters</td></tr>
</table>
<b>Returns:</b><br>Any array of strings minus the delimiters.
</dd>

<dt class="d_decl">@trusted pure string <a name="toCamelCase"></a><span class="funcName">toCamelCase</span>(string text, bool first = true)</dt>
<dd><p>Converts a regular string into <a href='http://en.wikipedia.org/wiki/CamelCase'>camel case</a>.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>string <i>text</i></td><td>The string to be modified</td></tr>
<tr><td class='code'>bool <i>first</i></td><td>If true, the first letter will be capitalised.</td></tr>
</table>
<b>Returns:</b><br>The converted string
</dd>

<dt class="d_decl">size_t <a name="altIndexOf"></a><span class="funcName">altIndexOf</span>(string s, char c)</dt>
<dd><p>A quick and dirty alternative to std.string.indexOf. Only works with ASCII.</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>string <i>s</i></td><td>The string to be searched</td></tr>
<tr><td class='code'>bool <i>first</i></td><td>The character to be looked for..</td></tr>
</table>
<b>Returns:</b><br>The index of the character, or s.length if not found.
</dd>

<dt class="d_decl">S1 <a name="grab"></a><span class="funcName">grab</span>(alias pred = "a == b",S1, S2)(ref S1 seq, S2 choices)</dt>
<dd><p>Grabs as much of <i>seq</i>, until a character is found that matches <i>choices</i>
 according to the given predicate. Returns the first part while setting
 <i>seq</i> to the remainder (including the found element).</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>S1 <i>seq</i></td><td>The range to be searched</td></tr>
<tr><td class='code'>S2 <i>choices</i></td><td>The range of elements to be compared against.</td></tr>
</table>
<b>Returns:</b><br>Returns what is grabbed, while seq is set to the remainder (including the found element).
</dd>

<dt class="d_decl">@safe pure nothrow bool <a name="isDigits"></a><span class="funcName">isDigits</span>(string text)</dt>
<dd><p>Are all characters ASCII digits?</p>

<b>Parameters:</b>
<table class='parms'>
<tr><td class='code'>string <i>text</i></td><td>The string to be tested</td></tr>
</table>
<b>Returns:</b><br>True if all characters in the string are ASCII digits.
</dd>

</dl>


</div>
</body>
</html>
